<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TTS Browser Source</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: transparent;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
    }

    #status {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      border-radius: 4px;
      font-size: 14px;
      display: none; /* Hidden by default for production */
    }

    #status.connected {
      background: rgba(40, 167, 69, 0.8);
    }

    #status.disconnected {
      background: rgba(220, 53, 69, 0.8);
    }    #queue-info {
      position: absolute;
      top: 50px;
      left: 10px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      border-radius: 4px;
      font-size: 12px;
      display: none; /* Hidden by default for production */
    }

    #unlock-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    #unlock-overlay.hidden {
      display: none;
    }

    #unlock-button {
      padding: 20px 40px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      border: none;
      border-radius: 8px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      transition: all 0.2s;
    }

    #unlock-button:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
    }

    #unlock-button:active {
      transform: scale(0.98);
    }
  </style>
</head>
<body>
  <!-- Unlock overlay (only needed for browser testing, not OBS) -->
  <div id="unlock-overlay">
    <button id="unlock-button">ðŸ”Š Click to Enable Audio</button>
  </div>

  <div id="status" class="disconnected">Disconnected</div>
  <div id="queue-info">Queue: 0 | Playing: None</div>  <!-- Hidden audio element for Azure/Google audio playback -->
  <audio id="audioPlayer" style="display: none;"></audio>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    console.log('[TTS Browser Source] Initializing...');

    // Connect to Socket.IO server
    const socket = io('http://localhost:3737');
    const audioPlayer = document.getElementById('audioPlayer');
    const statusDiv = document.getElementById('status');
    const queueDiv = document.getElementById('queue-info');
    const unlockOverlay = document.getElementById('unlock-overlay');
    const unlockButton = document.getElementById('unlock-button');

    let isPlaying = false;
    let currentProvider = null;
    let audioUnlocked = false;

    // Detect if running in OBS (OBS doesn't have Navigator.userAgentData)
    const isOBS = !navigator.userAgentData && navigator.userAgent.includes('Chrome');

    // Hide unlock button in OBS
    if (isOBS) {
      unlockOverlay.classList.add('hidden');
      audioUnlocked = true;
      console.log('[TTS Browser Source] Running in OBS - autoplay enabled');
    } else {
      console.log('[TTS Browser Source] Running in browser - click required to enable audio');
    }

    // Handle unlock button click
    unlockButton.addEventListener('click', () => {
      console.log('[TTS Browser Source] User clicked unlock button');
      
      // Play silent audio to unlock
      audioPlayer.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';
      audioPlayer.volume = 0;
      
      const playPromise = audioPlayer.play();
      
      if (playPromise !== undefined) {
        playPromise.then(() => {
          console.log('[TTS Browser Source] âœ“ Audio unlocked successfully');
          audioPlayer.pause();
          audioPlayer.currentTime = 0;
          audioPlayer.src = '';
          audioPlayer.volume = 1;
          audioUnlocked = true;
          unlockOverlay.classList.add('hidden');
        }).catch((error) => {
          console.error('[TTS Browser Source] Failed to unlock audio:', error);
        });
      }
    });

    // Socket connection events
    socket.on('connect', () => {
      console.log('[TTS Browser Source] âœ“ Connected to server');
      statusDiv.textContent = 'Connected';
      statusDiv.className = 'connected';
    });

    socket.on('disconnect', () => {
      console.log('[TTS Browser Source] âœ— Disconnected from server');
      statusDiv.textContent = 'Disconnected';
      statusDiv.className = 'disconnected';
      isPlaying = false;
    });

    socket.on('error', (error) => {
      console.error('[TTS Browser Source] Socket error:', error);
    });

    // Listen for TTS audio events
    socket.on('tts-audio', (data) => {
      console.log('[TTS Browser Source] ðŸ“¢ Received TTS audio:', {
        provider: data.provider,
        id: data.id,
        hasAudioData: !!data.audioData,
        hasText: !!data.text
      });

      if (isPlaying) {
        console.warn('[TTS Browser Source] Already playing, queuing is handled server-side');
        return;
      }

      playTTS(data);
    });

    // Play TTS based on provider
    async function playTTS(data) {
      isPlaying = true;
      currentProvider = data.provider;
      updateQueueInfo('Playing...', data.provider);

      try {
        if (data.provider === 'webspeech') {
          // WebSpeech: Synthesize text client-side
          await playWebSpeech(data);
        } else if (data.provider === 'azure' || data.provider === 'google') {
          // Azure/Google: Play audio file
          await playAudioFile(data);
        } else {
          console.error('[TTS Browser Source] Unknown provider:', data.provider);
        }
      } catch (error) {
        console.error('[TTS Browser Source] Playback error:', error);
      } finally {
        isPlaying = false;
        currentProvider = null;
        updateQueueInfo('Idle', null);
        
        // Notify server that audio finished
        socket.emit('tts-finished');
        console.log('[TTS Browser Source] âœ“ Audio finished, notified server');
      }
    }

    // Play WebSpeech audio (client-side synthesis)
    function playWebSpeech(data) {
      return new Promise((resolve, reject) => {
        if (!window.speechSynthesis) {
          console.error('[TTS Browser Source] Web Speech API not available');
          reject(new Error('Web Speech API not available'));
          return;
        }        console.log('[TTS Browser Source] Playing WebSpeech:', {
          text: data.text,
          voiceId: data.voiceId,
          rate: data.rate,
          pitch: data.pitch,
          volume: data.volume
        });        const utterance = new SpeechSynthesisUtterance(data.text);
        
        // Find the voice by voiceURI (we now send the actual voiceURI from backend)
        const voices = window.speechSynthesis.getVoices();
        let voice = voices.find(v => v.voiceURI === data.voiceId);
        
        // Fallback: Try matching by language if exact voiceURI not found
        // This handles cases where voice identifiers change between platforms
        if (!voice && data.voiceId && voices.length > 0) {
          console.warn('[TTS Browser Source] Exact voice URI not found, trying fallback matching');
          
          // Try to extract language from voiceURI (common formats: lang, lang-country, etc.)
          // For macOS: "com.apple.voice.compact.bg-BG.Daria" -> extract "bg-BG"
          const languageMatch = data.voiceId.match(/([a-z]{2}(-[A-Z]{2})?)/);
          if (languageMatch) {
            const language = languageMatch[1];
            console.log('[TTS Browser Source] Trying to match by language:', language);
            voice = voices.find(v => v.lang && v.lang.startsWith(language));
            if (voice) {
              console.log('[TTS Browser Source] Fallback: Using voice with matching language:', voice.name, '(', voice.lang, ')');
            }
          }
          
          // Last resort: use first available voice
          if (!voice && voices.length > 0) {
            console.warn('[TTS Browser Source] No matching voice found, using first available');
            voice = voices[0];
          }
        }
        
        if (voice) {
          utterance.voice = voice;
          console.log('[TTS Browser Source] Using voice:', voice.name, '(URI:', voice.voiceURI, ', lang:', voice.lang, ')');
        } else {
          console.warn('[TTS Browser Source] Voice not found:', data.voiceId);
          console.log('[TTS Browser Source] Available voices count:', voices.length);
          if (voices.length > 0) {
            console.log('[TTS Browser Source] Sample voices:', voices.slice(0, 5).map(v => `${v.name} (${v.voiceURI}, ${v.lang})`).join(', '));
          }
        }

        // Apply settings
        utterance.rate = data.rate || 1.0;
        utterance.pitch = data.pitch || 1.0;
        utterance.volume = (data.volume || 80) / 100;

        utterance.onend = () => {
          console.log('[TTS Browser Source] WebSpeech finished');
          resolve();
        };

        utterance.onerror = (event) => {
          console.error('[TTS Browser Source] WebSpeech error:', event);
          reject(event.error);
        };

        window.speechSynthesis.speak(utterance);
      });
    }

    // Play Azure/Google audio file
    function playAudioFile(data) {
      return new Promise((resolve, reject) => {
        if (!data.audioData) {
          console.error('[TTS Browser Source] No audio data provided');
          reject(new Error('No audio data'));
          return;
        }

        console.log('[TTS Browser Source] Playing audio file:', {
          provider: data.provider,
          format: data.audioFormat,
          dataLength: data.audioData.length
        });

        // Convert base64 to blob
        const binaryString = atob(data.audioData);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }

        const blob = new Blob([bytes], { 
          type: data.audioFormat === 'mp3' ? 'audio/mpeg' : 'audio/wav' 
        });
        const url = URL.createObjectURL(blob);

        // Try Web Audio API first (more reliable for autoplay on macOS)
        try {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          fetch(url)
            .then(response => response.arrayBuffer())
            .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
            .then(audioBuffer => {
              const source = audioContext.createBufferSource();
              source.buffer = audioBuffer;
              
              // Apply volume
              const gainNode = audioContext.createGain();
              gainNode.gain.value = (data.volume || 80) / 100;
              
              // Connect: source -> gain -> destination
              source.connect(gainNode);
              gainNode.connect(audioContext.destination);
              
              // Resolve when audio finishes
              source.onended = () => {
                console.log('[TTS Browser Source] Audio file finished (Web Audio API)');
                URL.revokeObjectURL(url);
                resolve();
              };
              
              // Start playback
              source.start(0);
              console.log('[TTS Browser Source] Playing audio via Web Audio API');
            })
            .catch(err => {
              console.warn('[TTS Browser Source] Web Audio API failed, trying HTML5 audio:', err);
              // Fallback to HTML5 audio element
              playWithAudioElement(url, data, resolve, reject);
            });
        } catch (err) {
          console.warn('[TTS Browser Source] Web Audio API not available, using HTML5 audio:', err);
          // Fallback to HTML5 audio element
          playWithAudioElement(url, data, resolve, reject);
        }
      });
    }

    // Fallback: Play audio using HTML5 audio element
    function playWithAudioElement(url, data, resolve, reject) {
      audioPlayer.src = url;
      audioPlayer.volume = (data.volume || 80) / 100;

      audioPlayer.onended = () => {
        console.log('[TTS Browser Source] Audio file finished (HTML5 Audio)');
        URL.revokeObjectURL(url);
        resolve();
      };

      audioPlayer.onerror = (event) => {
        console.error('[TTS Browser Source] Audio playback error:', event);
        URL.revokeObjectURL(url);
        reject(new Error('Audio playback failed'));
      };

      audioPlayer.play()
        .catch(err => {
          console.error('[TTS Browser Source] Failed to play audio:', err);
          console.warn('[TTS Browser Source] Autoplay may be restricted. Attempting to play silently first...');
          
          // Try playing with muted first, then unmute
          audioPlayer.muted = true;
          audioPlayer.play()
            .then(() => {
              console.log('[TTS Browser Source] Playing muted audio first...');
              setTimeout(() => {
                audioPlayer.muted = false;
                console.log('[TTS Browser Source] Audio unmuted');
              }, 100);
            })
            .catch(muteErr => {
              console.error('[TTS Browser Source] Even muted playback failed:', muteErr);
              URL.revokeObjectURL(url);
              reject(muteErr);
            });
        });
    }

    // Update queue info display
    function updateQueueInfo(status, provider) {
      queueDiv.textContent = `Status: ${status}${provider ? ` (${provider})` : ''}`;
    }    // Load voices when available (for WebSpeech)
    if (window.speechSynthesis) {
      window.speechSynthesis.onvoiceschanged = () => {
        const voices = window.speechSynthesis.getVoices();
        console.log(`[TTS Browser Source] Loaded ${voices.length} WebSpeech voices`);
      };
    }

    console.log('[TTS Browser Source] Ready');
  </script>
</body>
</html>
